<h2>Standard logging for JVM</h2>
<div class="step-text">
<h5 id="introduction-to-java-logging">Introduction to Java logging</h5><p><strong>Logs </strong>are records of a software application, which we choose to save to a file or display in a console. These records could describe anything: an event in the application, the value of a variable, an error or an exception in the application. Logs are mostly used for debugging purposes. Today, we'll learn about the <code class="language-kotlin">java.util.logging</code> package, which is responsible for giving the developers logging capabilities within Java's standard SDK. There are several components you need to learn when working with Java logging: the <code class="language-kotlin">Logger</code> class, the <code class="language-kotlin">FileHandler</code> class, the <code class="language-kotlin">ConsoleHandler</code> class, <code class="language-kotlin">SimpleFormatter</code>, <code class="language-kotlin">XMLFormatter</code>, <code class="language-kotlin">Level</code>, <code class="language-kotlin">LogRecord</code>, and <code class="language-kotlin">LogManager</code>. In this topic, we will discuss the first 6 of those and see how loggers, handlers, filters, and formatters work together.</p><p style="text-align: center;"><img alt="Java logging component hierarchy: Logger class, FileHandler class, ConsureHandler class, SimpleFormatter, XMLFormatter, Level, LogRecord and LogManager" height="150" src="https://ucarecdn.com/1a60851e-aff5-4486-97a6-4a6409a8ce72/" width="263"/></p><h5 id="logger-class">Logger class</h5><p>The <code class="language-kotlin">Logger</code> class is the most important and fundamental component in the logging package. The standard practice is to create a logger instance for each class. The <code class="language-kotlin">Logger</code> class introduces several methods to print log messages: the <code class="language-kotlin">log()</code> method is one of them. Check out the following example:</p><pre><code class="language-kotlin">import java.util.logging.Level
import java.util.logging.Logger

object Main {
    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
        val logger = Logger.getLogger(Main::class.java.name)
        logger.log(Level.WARNING, "Hello " + logger.name)
    }
}</code></pre><p>It will output:</p><pre><code class="language-java">WARNING: Hello Main</code></pre><p>First, we create a logger instance using the class name. Then we call the <code class="language-kotlin">log()</code> method to print the log message. The <code class="language-kotlin">log()</code> method takes two arguments: its first argument is a <strong>Level</strong> object, and the second argument is a message. <code class="language-kotlin">Level.WARNING</code> is a constant from the <code class="language-kotlin">Level</code><strong> </strong>class in the logging package.</p><p>Every log message is related to a certain log level. In the above example, it is <strong>Warning</strong>. Java uses <strong>Info </strong>as its default<strong> </strong>log level. There are seven<strong> </strong>log levels in Java's logging package. The list below shows them from the highest to the lowest severity.</p><ul><li><p><strong>SEVERE</strong></p></li><li><p><strong>WARNING</strong></p></li><li><p><strong>INFO</strong></p></li><li><p><strong>CONFIG</strong></p></li><li><p><strong>FINE</strong></p></li><li><p><strong>FINER</strong></p></li><li><p><strong>FINEST</strong></p></li></ul><p>The following image shows the integer values of the log levels:</p><p style="text-align: center;"><img alt="shows the integer values of the log levels" height="285" src="https://ucarecdn.com/83a2ec88-8daf-44e9-86a8-b2594e2b81ab/" width="358"/></p><p>The <code class="language-kotlin">Logger</code><strong> </strong>class contains methods, such as <code class="language-kotlin">info()</code> and <code class="language-kotlin">config()</code>, where you don’t need to provide a log level as an attribute.<br/>Check out the following example:</p><pre><code class="language-kotlin">import java.util.logging.Logger

object Main {
    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
        val logger = Logger.getLogger(Main::class.java.name)
        logger.severe("Severe Log")
        logger.warning("Warning Log")
        logger.info("Info Log")
    }
}</code></pre><p>The output will be:</p><pre><code class="language-kotlin">January 09, 2023 9:26:04 AM Main main
SEVERE: Severe Log
January 09, 2023 9:26:04 AM Main main
WARNING: Warning Log
January 09, 2023 9:26:04 AM Main main
INFO: Info Log</code></pre><h5 id="handlers-and-formatters">Handlers and formatters</h5><p>The next important components in the logging package are <strong>handlers </strong>and <strong>formatters</strong>, which often work together. Handlers<strong> </strong>are responsible for sending actual logs to the outside world. There is an abstract class called <code class="language-kotlin">Handler</code><strong> </strong>in the <code class="language-kotlin">java.util.logging</code><strong> </strong>package. It is extended by five concrete classes. Two most important classes among them are <code class="language-kotlin">ConsoleHandler</code> and <code class="language-kotlin">FileHandler</code>. <code class="language-kotlin">ConsoleHandler</code> writes log messages to System.err, while <code class="language-kotlin">FileHandler</code> writes log messages to a file.</p><p>Usually, a handler<strong> </strong>uses a formatter<strong> </strong>to format the log message. There are two types of formatters in the logging package. Those are <code class="language-kotlin">SimpleFormatter</code> and <code class="language-kotlin">XMLFormatter</code>. Of course, both of them extend the <code class="language-kotlin">Formatter</code><strong> </strong>abstract class in the logging package.<br/>Check out the following example to better understand handlers<strong> </strong>and formatters:</p><pre><code class="language-kotlin">import java.util.logging.FileHandler
import java.util.logging.Handler
import java.util.logging.Logger
import java.util.logging.XMLFormatter

object Main {
    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
        val logger = Logger.getLogger(Main::class.java.name)
        val fileHandler: Handler = FileHandler("default.log")
        logger.addHandler(fileHandler)
        fileHandler.formatter = XMLFormatter()
        logger.info("Info log message")
    }
}</code></pre><p>It will create a log file called <strong>default.log</strong>, which will contain the following XML text:</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE log SYSTEM "logger.dtd"&gt;
&lt;log&gt;
&lt;record&gt;
  &lt;date&gt;2023-01-09T07:29:56.688157Z&lt;/date&gt;
  &lt;millis&gt;1673249396688&lt;/millis&gt;
  &lt;nanos&gt;157000&lt;/nanos&gt;
  &lt;sequence&gt;0&lt;/sequence&gt;
  &lt;logger&gt;Main&lt;/logger&gt;
  &lt;level&gt;INFO&lt;/level&gt;
  &lt;class&gt;Main&lt;/class&gt;
  &lt;method&gt;main&lt;/method&gt;
  &lt;thread&gt;1&lt;/thread&gt;
  &lt;message&gt;Info log message&lt;/message&gt;
&lt;/record&gt;
&lt;/log&gt;</code></pre><h5 id="filters">Filters</h5><p>Let’s discuss <strong>filters </strong>now. When we are developing a software application, we write as many log messages as possible. But we don’t want all the log messages to be executed every time the application runs: it will waste resources and may result in unnecessarily long log files. That’s why we use filters. Let’s say you want to print only info messages. For that, first, you have to create a <strong>custom filter </strong>class by implementing the <code class="language-kotlin">Filter</code> interface in the logging package.</p><pre><code class="language-kotlin">class FilterExample : Filter {
    override fun isLoggable(record: LogRecord): Boolean {
        return if (record.level !== Level.INFO) {
            false
        } else true
    }
}</code></pre><p>Now, you create an object of the <code class="language-kotlin">FilterExample</code> class and then use the <code class="language-kotlin">filter</code> field of the Logger instance to set the filter.</p><pre><code class="language-kotlin">import java.util.logging.Filter
import java.util.logging.Level
import java.util.logging.LogRecord
import java.util.logging.Logger


object Main {
    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
        val logger = Logger.getLogger(Main::class.java.name)
        val filter: Filter = FilterExample()
        logger.filter = filter
        logger.severe("Severe Log")
        logger.info("Info Log")
        logger.warning("Warning Log")
    }
}</code></pre><p>When this code is executed, only the <code class="language-kotlin">Info log</code> message will be printed:</p><pre><code class="language-kotlin">January 09, 2023 9:36:42 AM Main main
INFO: Info Log</code></pre><h5 id="conclusion">Conclusion</h5><p>Let's summarize what we've learned in this topic. First, <code class="language-kotlin">java.util.logging</code> is part of the Java SDK, and it is responsible for giving logging capabilities to developers. We've discussed several components of the logging package. Logger instances are responsible for creating log messages. We usually create a logger instance for every class we are going to add logs to. Handlers are responsible for sending log message out of the application. If you want to print log messages to console, use <code class="language-kotlin">ConsoleHandler</code>. If you want to write log messages to a file, use <code class="language-kotlin">FileHandler</code>. Formatters format log messages. If you want to log messages in the XML format, use <code class="language-kotlin">XMLFormatter</code>. Finally, we discussed filters, which help you control which logs are to be executed when the application runs.</p>
</div>
