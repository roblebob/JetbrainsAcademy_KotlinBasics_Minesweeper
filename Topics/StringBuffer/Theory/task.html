<h2>StringBuffer</h2>
<div class="step-text">
<p><code class="language-kotlin">StringBuilder</code>, as you might already know, is a powerful tool that provides you with mutable strings. However, it may not be the best solution in situations where <strong>multiple threads</strong> need to modify the same <code class="language-kotlin">StringBuilder</code> object <strong>simultaneously</strong>. That's where <code class="language-kotlin">StringBuffer</code> comes in. It is a peer class to <code class="language-kotlin">StringBuilder</code>, with an additional feature: <strong>synchronization </strong>(a mechanism that ensures that only one thread can access a shared resource at a time, preventing race conditions and other concurrency issues). This makes <code class="language-kotlin">StringBuffer</code> thread-safe and a better choice for multi-threaded environments. However, there is a trade-off between synchronization and performance, which we will talk more about later on.</p><h5 id="constructors-of-stringbuffer">Constructors of StringBuffer</h5><p>Similar to the case of <code class="language-kotlin">StringBuilder</code>, we have various ways to create a <code class="language-kotlin">StringBuffer</code> object. We can initialize it as an empty object, set it with a suitable initial content (<code class="language-kotlin">String</code> or <code class="language-kotlin">CharSequence</code>), or specify a starting <code class="language-kotlin">capacity</code>.</p><ul><li><p>An empty <code class="language-kotlin">StringBuffer</code> with a default initial capacity (16 bytes) can be created using the default constructor:</p></li></ul><pre><code class="language-kotlin">val buffer = StringBuffer()</code></pre><ul><li><p>You can also create a <code class="language-kotlin">StringBuffer</code> with some initial content by passing a <code class="language-kotlin">String</code> to the constructor:</p></li></ul><pre><code class="language-kotlin">val buffer = StringBuffer("Kotlin")</code></pre><ul><li><p>If you want to specify the capacity of the <code class="language-kotlin">StringBuffer</code> at the time of creation, you can pass an <code class="language-kotlin">Int</code> to the constructor:</p></li></ul><pre><code class="language-kotlin">val buffer = StringBuffer(10) // creates a StringBuffer with an initial capacity of 10 characters</code></pre><p></p><div class="alert alert-primary"><p>It's worth noting that <code class="language-kotlin">StringBuffer</code> is a Java class. However, you can use it directly in Kotlin without importing anything, since it belongs to the <code class="language-kotlin">java.lang</code> package, which is automatically imported.</p></div><p> </p><p></p><h5 id="methods-of-stringbuffer">Methods of StringBuffer</h5><p><code class="language-kotlin">StringBuffer</code> shares many similar methods with <code class="language-kotlin">StringBuilder</code>, so we will briefly mention a few of them as a reminder. However, it's important to note that there is a crucial difference under the hood. A closer look at the <code class="language-kotlin">StringBuffer</code> class inside the <code class="language-kotlin">java.lang</code> library reveals that all <code class="language-kotlin">StringBuffer</code> methods are marked with the <code class="language-kotlin">synchronized</code> modifier. This is what makes <code class="language-kotlin">StringBuffer</code> synchronized and thread-safe, allowing it to be used by multiple threads without the need for external synchronization.</p><p><img alt="Declaration of append method in java.lang library" height="248" src="https://ucarecdn.com/cb15b759-c893-4366-a5d5-36452d6d2f4a/" width="606"/></p><p>Now, let's review those methods:</p><table border="1" cellpadding="1" cellspacing="1" style="width: 500px;"><tbody><tr><th><p>Method</p></th><th><p>Description</p></th></tr><tr><td style="width: 30%;"><p><code class="language-kotlin">capacity</code></p></td><td><p>Retrieves the current capacity (number of characters that can be stored without reallocation) of a <code class="language-kotlin">StringBuffer</code></p></td></tr><tr><td><p><code class="language-kotlin">length</code></p></td><td><p>Retrieves the current length (number of characters) of a <code class="language-kotlin">StringBuffer</code></p></td></tr></tbody></table><pre><code class="language-kotlin">val buffer = StringBuffer("Kotlin")

println("Length: ${buffer.length}")       // "Length: 6"
println("Capacity: ${buffer.capacity()}") // "Capacity: 22" (initial capacity + length of String passed to constructor = 16 + 6)
</code></pre><p> </p><table border="1" cellpadding="1" cellspacing="1" style="width: 500px;"><tbody><tr><th><p>Method</p></th><th><p>Description</p></th></tr><tr><td style="width: 30%;"><p><code class="language-kotlin">append</code></p></td><td><p>Adds a String at the end of a <code class="language-kotlin">StringBuffer</code></p></td></tr><tr><td><p><code class="language-kotlin">insert</code></p></td><td><p>Inserts a String at a specific position in a <code class="language-kotlin">StringBuffer</code></p></td></tr><tr><td><p><code class="language-kotlin">delete</code></p></td><td><p>Removes a range of characters from a <code class="language-kotlin">StringBuffer</code></p></td></tr><tr><td><p><code class="language-kotlin">replace</code></p></td><td><p>Replaces a range of characters with a new <code class="language-kotlin">String</code></p></td></tr><tr><td><p><code class="language-kotlin">reverse</code></p></td><td><p>Reverses the order of characters in the <code class="language-kotlin">StringBuffer</code></p></td></tr></tbody></table><pre><code class="language-kotlin">val secretMessage = StringBuffer()

secretMessage
    .append("like")
    .insert(3, "srepyHigh")
    .delete(9, 13)
    .replace(0, 1, "ll")
    .reverse()

println(secretMessage) // "Hyperskill"
</code></pre><p></p><div class="alert alert-warning"><p>When using a <code class="language-kotlin">StringBuffer</code> to append or insert data from a source sequence that is shared across threads, it is important to ensure that the source sequence is not modified by other threads while the operation is in progress. This is because only the methods of the <code class="language-kotlin">StringBuffer</code> are synchronized, not the <code class="language-kotlin">StringBuffer</code> itself.</p></div><p></p><h5 id="proper-usage-of-each-class">Proper usage of each class</h5><p>It's important to choose the right class for a certain job. Depending on your specific requirements and constraints, either <code class="language-kotlin">StringBuilder</code> or <code class="language-kotlin">StringBuffer</code> might be the more suitable choice. Let's explore some real-world scenarios to help you make informed decisions.</p><p>Best scenarios for using <code class="language-kotlin">StringBuilder</code>:</p><ol><li><p><strong>String concatenation:</strong> If you're working on tasks that involve heavy string concatenation operations, such as generating dynamic SQL queries or constructing large JSON/XML payloads, <code class="language-kotlin">StringBuilder</code> is an excellent choice. Its mutable nature allows for efficient appending of strings, reducing memory consumption and avoiding unnecessary object creations.</p></li><li><p><strong>Logging and formatting:</strong> When logging or formatting messages that involve dynamic or variable data, <code class="language-kotlin">StringBuilder</code> proves beneficial. By appending different values or variables to the <code class="language-kotlin">StringBuilder</code>, you can efficiently build complex log messages or formatted strings without unnecessary overhead.</p></li><li><p><strong>Generating HTML or XML markup:</strong> When dynamically generating HTML or XML markup, <code class="language-kotlin">StringBuilder</code> can be a suitable choice. It allows you to efficiently build the structure and content of the markup by appending tags, attributes, and values without incurring unnecessary overhead.</p></li></ol><p>Best scenarios for using <code class="language-kotlin">StringBuffer</code>:</p><ol><li><p><strong>Concurrent data processing: </strong>When processing data concurrently in a multi-threaded environment, <code class="language-kotlin">StringBuffer</code> can be used to safely manipulate shared strings. For example, if multiple threads need to extract and process data from a shared log file or data stream, <code class="language-kotlin">StringBuffer</code> can be used to ensure that the data is consistently and accurately processed.</p></li><li><p><strong>Multi-threaded text generation:</strong> In applications that generate text concurrently, such as report generation or document formatting, <code class="language-kotlin">StringBuffer</code> can be used to safely build the final text output. By using <code class="language-kotlin">StringBuffer</code>, multiple threads can append text to the shared buffer without worrying about synchronization issues.</p></li><li><p><strong>Thread-safe string caching:</strong> In applications that cache frequently used strings, such as web servers or database systems, <code class="language-kotlin">StringBuffer</code> can be used to implement a thread-safe cache. By using <code class="language-kotlin">StringBuffer</code>, multiple threads can safely access and manipulate the cached strings without data corruption or inconsistencies.</p></li></ol><h5 id="converting-stringbuffer-to-string">Converting StringBuffer to String</h5><p>Converting a <code class="language-kotlin">StringBuffer</code> to a <code class="language-kotlin">String</code> allows you to obtain an immutable representation of the modified content for further processing or passing it to methods that expect a <code class="language-kotlin">String</code> parameter. This can be achieved using the <code class="language-kotlin">toString</code> method:</p><pre><code class="language-kotlin">val buffer = StringBuffer("Hyperskill")
val string = buffer.toString()
println(string) // "Hyperskill"</code></pre><p>The <code class="language-kotlin">toString</code> method returns a new <code class="language-kotlin">String</code> object that represents the content of the <code class="language-kotlin">StringBuffer</code>. Therefore, any subsequent changes made to the <code class="language-kotlin">StringBuffer</code> after calling <code class="language-kotlin">toString</code> will not affect the <code class="language-kotlin">String</code> object. It is important to convert a <code class="language-kotlin">StringBuffer</code> to a <code class="language-kotlin">String</code> when you no longer need to modify the content or want to ensure its immutability.</p><h5 id="the-price-of-synchronization">The price of synchronization</h5><p>When trying to choose between <code class="language-kotlin">StringBuilder</code> and <code class="language-kotlin">StringBuffer</code>, you should consider the trade-off between synchronization and performance. Synchronization in <code class="language-kotlin">StringBuffer</code> comes at a cost: it introduces a slight overhead, making it slightly slower than <code class="language-kotlin">StringBuilder</code>. Therefore, if thread safety is not a concern in your specific scenario, it will be more efficient to use <code class="language-kotlin">StringBuilder</code>. It's worth noting that <code class="language-kotlin">StringBuffer</code> has been a part of Java since its initial release (Java $1.0$), while <code class="language-kotlin">StringBuilder</code> was introduced as a lightweight alternative in Java $5.0$, offering improved performance for non-thread-safe operations.</p><p>So, while both classes serve the purpose of creating and manipulating mutable sequences of characters and share similar methods, there is one crucial distinction: <code class="language-kotlin">StringBuffer</code> is thread-safe, which enables its usage by multiple threads without requiring external synchronization. On the other hand, <code class="language-kotlin">StringBuilder</code> is not thread-safe and should only be used by a single thread.</p><p>Let's see the price of synchronization paid in a real example:</p><pre><code class="language-kotlin">const val N = 99999999 // Number of iterations for the test

fun main() {
    var time: Long
    var executionTime: Long

    println("For the same task:")

    // Using StringBuffer
    val buffer = StringBuffer()
    time = System.currentTimeMillis() // We save the start time of the task
    for (i in N downTo 1) {
        buffer.append("")
    }
    executionTime = System.currentTimeMillis() - time // We find the execution time of the task
                                                      // by subtracting the start time from the end time
    println("StringBuffer gets it finished in $executionTime ms,")

    // Using StringBuilder
    val builder = StringBuilder()
    time = System.currentTimeMillis()
    for (i in N downTo 1) {
        builder.append("")
    }
    executionTime = System.currentTimeMillis() - time
    println("while StringBuilder gets it finished in just $executionTime ms!")
}</code></pre><p>The output of this code will look like this:</p><pre><code class="language-no-highlight">For the same task:
StringBuffer gets it finished in 1999 ms,
while StringBuilder gets it finished in just 193 ms!</code></pre><p>In this example, we perform a test where both <code class="language-kotlin">StringBuffer</code> and <code class="language-kotlin">StringBuilder</code> are used to repeatedly append an empty string <code class="language-kotlin">N</code> times. We measure the execution time for each approach using the <code class="language-kotlin">System.currentTimeMillis()</code> method.</p><p>When you run this code, you will notice that <code class="language-kotlin">StringBuilder</code> performs significantly faster than <code class="language-kotlin">StringBuffer</code>, due to the overhead of synchronization of the latter. Please note that the actual execution times may vary based on the system and environment where the code is run.</p><h5 id="conclusion">Conclusion</h5><p>When multiple threads try to access and modify the same <code class="language-kotlin">StringBuilder</code> object at the same time, they may cause data inconsistency or corruption. <code class="language-kotlin">StringBuffer</code>, on the other hand, is a synchronized and thread-safe version of <code class="language-kotlin">StringBuilder</code>. It ensures that only one thread can access and modify the string at a time, preventing any concurrency issues. However, this comes at a cost of performance and memory overhead. Therefore, you should use <code class="language-kotlin">StringBuffer</code> only when you need to share the string among multiple threads; otherwise, <code class="language-kotlin">StringBuilder</code> is a better option. Now it's time for you to buffer some practice.</p>
</div>
